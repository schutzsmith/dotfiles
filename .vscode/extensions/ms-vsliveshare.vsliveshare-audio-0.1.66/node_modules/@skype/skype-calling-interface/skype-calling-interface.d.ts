// =============================================================================
// Typescript Definition file for component skype-calling-interface
//
// THIS FILE GOT AUTO-GENERATED BY generateDts.ts.
// =============================================================================

// -----------------------------------------------------------------------------
// Component 'skype-calling-interface'
// -----------------------------------------------------------------------------
declare module skype.calling {

export const enum CallState {
    None = 0,
    Notified = 1,       // Ringing state for incoming calls
    Connecting = 2,     // Connecting to call
    Connected = 3,      // Connected to call
    LocalHold = 4,      // Call is in local hold state
    RemoteHold = 5,     // Call is in remote hold state
    Disconnecting = 6,  // Session is disconnecting
    Disconnected = 7,   // Session is disconnected
    Observing = 8,      // Subscribed to the conversation
    EarlyMedia = 9,     // Set to this state based on receipt of early media while call is connecting
    InLobby = 10,       // User is connected to lobby
    Preheating = 11,    // Connecting state for preheat call
    Preheated = 12      // Session is established with out the user appearing in roster and with out media
}

export const enum ServiceType {
    Testing = 0,
    MicrosoftWNS = 1,
    MicrosoftWP7NS = 2,
    AppleAPN = 3,
    GoogleAGCM = 4,
    Hotmail = 5,
    GoogleAC2DM = 6,
    Trouter = 7,
    Griffin = 8,
    ADM = 9,
    NNA = 10
}

export const enum TransferState {
    None = 0,       // Default/Initial state
    Started = 1,    // Set after transferor calls any transfer API
    Accepted = 2,   // Set after transferee has accepted
    Completed = 3,  // Set after transferee has completed (with success)
    Failed = 4      // Set after transferee has completed (with failure)
}

export const enum CallOrigin {
    Unspecified,
    Transfer,
    Park
}

export const enum ParkState {
    None = 0,       // Default/Initial state
    Started = 1,    // Set after parkee starts call with CPS
    Parking = 2,    // Set after parker calls park API
    Parked = 3,     // Set after parking has completed (with success)
    Failed = 4      // Set after parking has completed (with failure)
}

export type PickUpCode = string | string & { isPickupCode: string };

export type CauseId = string | string & { isCauseId: string };

export const enum ParkContext {
    Team,
    SharedLine,
    ServerHold
}

export const enum TransferType {
    Transfer,
    Park
}

export const enum ParticipantState {
    None = 0,
    Connecting = 1,
    Ringing = 2,
    Connected = 3,
    Disconnected = 4,
    OnHold = 5,
    EarlyMedia = 6,
    InLobby = 7
}

export const enum ParticipantStateReason {
    None = 0,
    AddingFailed = 1,
    NoResponse = 2,
    Declined = 3,
    NotReachable = 4,
    Blocked = 5,
    NotFriendOrAuthorized = 6,
    CallLimitReached = 7,
    CallNotFound = 8,
    NetworkError = 9,
    MediaDroppedError = 10,
    OtherError = 11,
    PstnInsufficientFunds = 12,
    PstnSkypeoutAccountBlocked = 13,
    PstnCouldNotConnectToSkypeProxy = 14,
    PstnBlockedByUs = 15,
    PstnBlockedRegulatoryIndia = 16,
    PstnInvalidNumber = 17,
    PstnNumberForbidden = 18,
    Busy = 19,
    PstnCallTerminated = 20,
    PstnNumberUnavailable = 21,
    PstnEmergencyCallDenied = 22,
    Cancelled = 23,
    Dropped = 24, // deprecated
    PstnNoSubscriptionCover = 25,
    PstnCreditExpired = 26,
    PstnCreditExpiredButEnough = 27,
    EnterprisePstnInternalError = 28,
    EnterprisePstnUnavailable = 29,
    EnterprisePstnForbidden = 30,
    EnterprisePstnInvalidNumber = 31,
    EnterprisePstnMiscError = 32,
    Kicked = 33,
    NetworkRequestTimeoutError = 34,
    CallDoesNotExist = 35,
    MediaSetupFailure = 36,
    ServiceUnavailable = 37,
    SignalingError = 38,
    ConversationEstablishmentFailed = 39,
    TemporarilyUnavailable = 40,
    CannotConnectToNetworkError = 41,
    NoSignalingFromPeer = 42,
    ParticipantDoesNotExist = 43,
    DeniedInLobby = 44,
    TimedOutInLobby = 45,
    ConfParticipantCountLimitReached = 46,
    Abandoned = 47,
    ActionNotAllowed = 48,
    ForbiddenDueToPolicy = 49, // User doesn't have credentials to perform an activity
    InsufficientCapabilitiesForCallee = 50, // User isn't capable of cloud audio-video conferences
    AccessDenied = 51, // Default reason for PreconditionFailed
    NoPermission = 52, // Default reason for Forbidden
    AnonymousJoinDisabledByPolicy = 53, // Anonymous users cannot join by policy
    NoLobbyForBroadcastJoin = 54, // Lobby is not supported for broadcast meetings
    NotAllowedDueToInformationBarrier = 55, // Call failed due to an information barrier
    BroadcastLimitReached = 56, // Broadcast limit reached for the tenant
    B2bJoinDisabledByPolicy = 57, // B2B users cannot join by policy
    LocationBasedRoutingError = 58, // Location based routing policy restriction error
    ConfLobbyParticipantCountLimitReached = 59 // Lobby participant limit reached
}

export const enum CallSupport {
    Supported,
    BrowserNotSupported,
    IncompatibleVersions
}

export const enum FailureType {
    CallSetupFailed,
    CallDropped,
    Undefined
}

export interface QualityChangedEvent {
    type: QualityEventType;
    value: QualityLevel;
    isLocalSource: boolean;
    mediaType: MediaType;
    id?: string; // participant mri or undefined if call quality changed
}

export const enum QualityLevel {
    Unknown = 0,
    Good = 1,
    Poor = 2,
    Bad = 3
}

export const enum QualityEventType {
    NetworkSendQuality = 1,
    NetworkRecvQuality = 2,
    NetworkDelay = 3,
    NetworkBandwidthLow = 4,
    NetworkReconnect = 5,
    NetworkPacketLoss = 6,
    NetworkJitter = 7,
    NetworkRateMatching = 8,
    DeviceCaptureNotFunctioning = 9,
    DeviceRenderNotFunctioning = 10,
    DeviceRenderGlitches = 11,
    DeviceLowSNR = 12,
    DeviceLowSpeechLevel = 13,
    DeviceClipping = 14,
    DeviceEcho = 15,
    DeviceNearEndToEchoRatio = 16,
    DeviceHalfDuplexAec = 17,
    DeviceMultipleEndpoints = 18,
    DeviceHowling = 19,
    DeviceRenderZeroVolume = 20,
    DeviceRenderMute = 21,
    NetworkSendCatastrophic = 22,
    NetworkRecvCatastrophic = 23,
    CpuInsufficient = 24,
    DeviceCaptureMute = 25,
    DeviceCaptureNotMuteButSilent = 26,
    DeviceSpeakWhileMuted = 27,
    VideoVbssRendered = 28,
    NetworkEthernetInterfaceUsed = 29,
    NetworkWlanInterfaceUsed = 30,
    NetworkWwanInterfaceUsed = 31,
    NetworkRelaysNotReachable = 32,
    VideoCapturerDeviceStartFailed = 33,
    VideoCapturerDeviceStartTimedOut = 34,
    VideoCapturerDeviceStartFailureLackSystemRes = 35,
    VideoCapturerDeviceStartFailureMFResConflict = 36,
    NoNetwork = 37,
    NetworkNotWorking = 38,
    DeviceCaptureNotFunctioningDeviceInUse = 39,
    DeviceRenderNotFunctioningDeviceInUse = 40,
    DeviceCaptureNotFunctioningAudioSrvNotRunning = 41,
    DeviceRenderNotFunctioningAudioSrvNotRunning = 42,
    ZeroCaptureDevicesEnumerated = 43,
    ZeroRenderDevicesEnumerated = 44,
    VideoCaptureDeviceFreeze = 45,
    AudioCapturePermissionDenied = 46,
    VideoCapturePermissionDenied = 47,
    VideoCaptureFreezeRecovered = 48,
    DeviceRenderHowling = 49,
    LowFarEndInput = 50,
    ImageRenderingQuality = 51
}

export const enum StreamType {
    Video = 0,
    ScreenSharing = 1
}

export const enum MuteScope {
    All = 0,
    Specified = 1
}

export const enum CallingIntent {
    Incoming,
    Outgoing,
    WarmPush,
    MediaInit
}

export type EventCallback = (...args: any[]) => void;
export type ObservableChangedCallback = () => void;

export interface IDisposable {
    dispose(causeId?: CauseId): void;
}

export interface IObservableObject<T> {
    changed(callback: ObservableChangedCallback): IDisposable;
    on<P extends keyof T>(event: P, callback: T[P]): IDisposable;
    once<P extends keyof T>(event: P, callback: T[P]): IDisposable;
}

export const enum ConnectionType {
    AllSupported = 0,
    NoDirectConnection
}

export interface IncomingCallPayload {
    conversationId: string;
    messageId: string;
    callerId: string;
    convoCallId: string;
    participantId?: string;
    isMultiParty: boolean;
    fromMixer?: boolean;
    ngcCall: boolean;
    body: {
        evt?: number;
        gp: string;
        cp?: string;
        nsp: string;
    };
    transferorId?: string;
    transferorType?: string;
    transferorDisplayName?: string;
    callType?: IncomingCallType;
    videoCall: boolean;
    launchTime: number;
    pushReceivedTime: number;
    registrationId: string;
    callKey?: string;
    connectionType?: ConnectionType;
    callQueueInfo?: CallQueueInfo;
    consultativeCallId?: string;
}

export interface IStream extends IObservableObject<{}> {
    isAvailable: boolean;
    isStreaming: boolean;
    participantId?: string;
    endpointId?: string;

    // negotiationTag represents the tag when starting or stopping a stream. It can optionally be
    // passed by the client to correlate the a screen sharing session e2e between sharer and viewers.
    negotiationTag?: string;

    isActive(): boolean;
}

export interface Size {
    width: number;
    height: number;
}

export const enum ScalingMode {
    Stretch,
    Crop,
    Fit
}

export const enum RendererErrorType {
    Unknown = -1,
    CaptureError = 0,
    RendererFailed = 1,
    RendererFailedGpuContext = 2,
    RendererFailedUnavailable = 3
}

export interface IRendererError {
    reason: any;
    errorType: RendererErrorType;
}

export const enum RendererType {
    Unknown = -1,
    VideoElement = 0,
    WebGLv1 = 1,
    WebGLv2 = 2,
    Pepper = 3,
    ReactNative = 4
}

export const enum FrameType {
    Unknown = -1,
    None = 0,
    Software = 1,
    Hardware = 2
}

export type RendererStats = {
    framesDropped: number;
    framesTotal: number;
};

export interface IRendererEvents {
    frameTypeChanged(frameType: FrameType): void;
    firstFrameRendered(): void;
    fullFrameRenderRequired(fullFrameRenderRequired: boolean): void;
}

export interface IVideoFrame {
    getSize(): Size;
    isMirrored(): boolean;
}

export interface IRenderer extends IDisposable, IObservableObject<IRendererEvents> {
    readonly isRendering: boolean;
    readonly streamSize: Size;
    readonly rendererType: RendererType;
    readonly frameType: FrameType;

    captureFrame(timeoutMs: number): Promise<IVideoFrame>;
    getStats(): Promise<RendererStats>;
    setScalingMode(scalingMode: ScalingMode, causeId?: CauseId): Promise<void>;
    setVideoEffects(effectsType: VideoEffectType, causeId?: CauseId): Promise<void>;
    getVideoEffectsCapability(): Promise<number>;
    dumpVideoSourceImages(): Promise<number>;
}

export type FrameSink = any;

export type ElectronElement = {
    renderer: any;
};

export interface RNElement {
    attachVideo(key: number, position: CameraPosition, options: StartStreamOptions): Promise<void>;
    attachVideoWithId?(id: number, videoObjectId: number, position: CameraPosition, options: StartStreamOptions): Promise<void>;
    detachVideo(): Promise<void>;
    captureFrame?(timeoutMs: number): Promise<IVideoFrame>;
    updateScalingMode(scalingMode: ScalingMode): Promise<void>;
}

export type IRenderTarget = HTMLElement | ElectronElement | RNElement;

export const enum MediaType {
    Audio,
    Video,
    PanoramicVideo,
    ScreenShare,
    Data
}

export const enum MuteFlags {
    // This will mute your microphone
    MuteMicrophone = 1 << 0, // tslint:disable-line:no-bitwise
    // This will mute your physical speaker so you will not hear audio
    MuteSpeaker = 1 << 1 // tslint:disable-line:no-bitwise
}

export const enum PreheatFlags {
    /* tslint:disable:no-bitwise */
    // Start the call in preheat mode
    IsPreheatOnly = 1 << 0
    /* tslint:enable:no-bitwise */
}

export const enum MediaDirection {
    Disabled,
    ReceiveOnly,
    SendOnly,
    Inactive,
    Bidirectional
}

export const enum MediaNegotiationStatusCode {
    Succeeded,
    ErrorLocalInternal,
    ErrorRemoteInternal,
    OfferNotAcceptable,
    OfferDeclined,
    LocalCancel,
    RemoteCancel,
    FailedNoRetry,
    Terminated,
    GeneralFailure
}

export const enum AnswerMediaType {
    AnswerWithAudioOnly,
    AnswerWithAudioVideo,
    AnswerWithScreenshareOnly
}

export const enum MediaStreamDirection {
    Receive,
    Send
}

export const enum MediaStreamState {
    Started,
    Inactive,
    Active,
    Stopped,
    Failed
}

// EndpointType is used to represent the identity type of a user/bot endpoint
export type EndpointType = 'default' | 'lync' | 'voicemail';

export type ParticipantRosterRole = 'admin' | 'guest';

// Determines the behavior of RemoveParticipant operation when passed list of endpoints.
// Specified    - The list of endpoints will behave as an *inclusive* list of endpoints to
//                be removed. NO other endpoints will be removed. This will be marked as
//                'specified' on the request sent to service
// Other        - The list of endpoints will behave as an *exclusive* list of endpoints to
//                be removed. ALL endpoints except the ones specified will be removed.
//                This will be marked as 'all' on the request sent to service
export const enum RemoveEndpointScope {
    Specified = 0,
    Other = 1
}

// Capabilities represent a user's ability to perform an action in the call. This is represented by a bitmask.
export type Capabilities = {
    canConference: boolean;   // Indicates the ability for a participant to be part of a conference call
    canShareScreen: boolean;  // Indicates the ability for a participant to share and/or view screen
    canMerge: boolean;        // Indicates the ability to merge the participant to another 1-1 or group call
};

export const enum ControlState {
    None,
    RequestSent,
    WaitingForControlAck,
    RemoteControlling,
    LocalControlling,
    WaitingForTerminateAck
}

export const enum ControlTerminatedReason {
    None,
    SharerDenied,
    SharerNoResponse,
    SharerBusy,
    AckTimeout,
    SharerTerminated,
    ViewerTerminated,
    DataChannelError,
    ViewerCancelled,
    SharerControlDisabled,
    UnknownSender
}

export interface MediaStreamInfo {
    mediaType: MediaType;
    mediaDirection: MediaStreamDirection;
    mediaStreamState: MediaStreamState;
}

export interface EndpointMediaStreamInfo {
    direction: string;
    label: string;
    sourceId: number;
    type: string;
}

export interface StartStreamOptions {
    scalingMode: ScalingMode;
    transparent: boolean;
    ignoreMirroring?: boolean;
    rendererTobeReparented?: IRenderer;
    disposeRendererWhenStreamisNotAvailable?(): boolean;
}

export interface ICallParticipantStream extends IStream, IDisposable, IObservableObject<{}> {
    id: number;
    type: StreamType;
    rank: number;

    start(target: IRenderTarget, options?: StartStreamOptions): Promise<IRenderer>;
    stop(): Promise<void>;

    // useful diagnostic data that gets collected during BRB to help analyze logs better
    getDiagnosticData(): string;
}

// AdmissionType is used to define the type of users allowed in to the meeting
export type AdmissionType = 'default' | 'anonymous' | 'open';

// Allowed Pstn Conferencing Dialout Type
export type PstnConferencingDialoutType = 'disabled' | 'domesticOnly' | 'internationalAndDomestic';

// Allowed App Desktop sharing type
export type AppDesktopSharingType = 'none' | 'singleApplication' | 'desktop';

export interface MeetingCapabilities {
    allowAnonymousUsersToDialOut?: boolean;
    admissionType?: AdmissionType;
    allowAnonymousUsersToStartMeeting?: boolean;
    admitAnonymousUsersByDefault?: boolean;
    appDesktopSharingType?: AppDesktopSharingType;
    allowVideo?: boolean;
    allowDialinConferencing?: boolean;
    allowCloudRecording?: boolean;
    pstnConferencingDialoutType?: PstnConferencingDialoutType;
    presenterOption?: PresenterOption;
    [key: string]: any;
}

export interface MeetingDetails {
    capabilities?: MeetingCapabilities;
    invitation?: string;
    [key: string]: any;
}

// This is for debuging and diagnosis only and NOT to be used for functional error mapping.
export interface CallEndDiagnosticsInfo {
    callControllerCode?: number;
    callControllerSubCode?: number;
}

export interface TransactionEnd {
    code?: number; // indicates the error code. 0 means sucess.
    subCode?: number; // indicates the sub classification under the code.
    phrase?: string; // user friendly documentation describing the error.
}

export type CapabilitiesValue = 'enabled' | 'disabled';

export interface CallParticipantCapabilities {
    serverMuteUnmute?: CapabilitiesValue;
}

export interface LwjSessionInformation {
}

export interface CallParticipantEndpointDetails {
    clientVersion: string;
    participantId: string;  // unique ID per connection to the call
    endpointId: string;     // unique ID per user in the call
    endpointType: EndpointType;  // The endpoint type for the current endpoint.
    endpointMetadata: any;  // application-specific blob
    originalId?: string;    // original id from the call me back scenario.
    capabilities?: CallParticipantCapabilities; // capabilities blob
    mediaStreams?: EndpointMediaStreamInfo[];   // for multi-party, contains information about streams
    lwjSessionInformation?: LwjSessionInformation;
    contentSharingRole?: ParticipantContentSharingRole;
}

export interface CallParticipantEndpoints {
    endpointDetails: CallParticipantEndpointDetails[];
}

export interface CallParticipantBalanceUpdateSender {
    endpointId: string;   // Sender's endpoint id.
}

export interface CallParticipantBalanceUpdate {
    accountBalance?: number;          // Account balance.
    accountCurrency?: string;         // Should be same as account currency at the time of the call.
    cdrIdString?: string;             // Pstn call debuginfo string (to report quality problems).
    emergencyCallCountry?: string;    // Country Code in case of emergency call.
    limitingFactor?: number;          // Used in conjunction with secondsLeft, specifies the context for the publication of that value; e.g. use of a credit-based calling plan.
    minutePrice?: number;             // Price per minute denominated in accountCurrency and adjusted by pricePrecision.
    pricePrecision?: number;          // Decimal points in minutePrice.
    secondsLeft?: number;             // Number of seconds left for call leg.
    sender: CallParticipantBalanceUpdateSender;   // Sender of this balance update message.
}

export interface CallParticipantBalanceUpdateMap {
    [endpointId: string]: CallParticipantBalanceUpdate;
}

export type CallParticipantStreamMap = {
    // StreamType -> ICallParticipantStream[]
    [type: number]: ICallParticipantStream[];
};

export interface ICallParticipant extends IDisposable, IObservableObject<{}> {
    // MRI formatted identity for the participant. Ex: 8:batman;aliases=2:darkknight@gotham.net
    id: string;
    displayName: string;
    role?: ParticipantRosterRole;
    tenantId?: string;

    // Represents active speaker bit for the participant.Non-zero value indicates active and 0 means inactive.
    voiceLevel: number;

    // Indicates if this person is muted in a group call. This property is applicable only for group calls.
    // This is the aggregated mute state for the user across all endpoints.
    // i.e isServerMuted is true only if participant is muted on all the endpoints and false otherwise.
    isServerMuted: boolean;

    // The call state for the participant. stateReason represents the end state error for the participant.
    state: ParticipantState;
    stateReason: ParticipantStateReason;

    // Streams for the participant.
    streams: CallParticipantStreamMap;

    // The capabilities of the participant in a call
    participantCapabilities: Capabilities;

    // Indicates the "onbehalfof" relationship when this participant is represented by an overloaded identity.
    // Ex: in case of call forwarding, id will contain original target but acceptedBy contains final forwarded target.
    acceptedBy: string;

    // All the active  endpoints associated with the participant.
    endpoints?: CallParticipantEndpoints;
    contentSharingRole: ParticipantContentSharingRole;

    // Call termination diagnostics code/subcode. This is exposed to enable client to capture additional
    // telemetry for alerting and diagnosis only and not for functional reasons.
    callEndDiagnosticsInfo?: CallEndDiagnosticsInfo;

    // Most recent balance update, if any, associated with the participant.
    balanceUpdates: CallParticipantBalanceUpdateMap;

    // role in a structured meeting
    meetingRole?: MeetingRole;

    // client needs to have access to source id, when injecting an event via control injector.
    // TODO: ICallParticipant.endpoints[0].mediaStreams[index].sourceId should be able to provide the same info.
    // If that works as expected this can/should be removed.
    getSourceIdForMediaType(mediaType: MediaType): number;

    // useful diagnostic data that gets collected during BRB to help analyze logs better
    getDiagnosticData(): string;
}

export interface DominantSpeakerInfo {
    speakerList: string[];
    timestamp: Date;
}

export const enum TerminatedReason {
    Undefined = 0,
    Success = 1,
    NoNgcEndpoint = 2,
    NetworkError = 3, // More general network error like losing trouter connectivity
    MediaDroppedError = 4,
    BadRequest = 5,
    CallEstablishmentTimeout = 6,
    CallSetupError = 7,
    NoPermission = 8,
    Missed = 9,
    Declined = 10,
    Busy = 11,
    Cancelled = 12,
    Dropped = 13, // deprecated
    PstnInsufficientFunds = 14,
    PstnSkypeoutAccountBlocked = 15,
    PstnCouldNotConnectToSkypeProxy = 16,
    PstnBlockedByUs = 17,
    PstnBlockedRegulatoryIndia = 18,
    PstnInvalidNumber = 19,
    PstnNumberForbidden = 20,
    PstnCallTerminated = 21,
    PstnNumberUnavailable = 22,
    PstnEmergencyCallDenied = 23,
    CallNotFound = 24,
    LocalError = 25,
    NotAcceptableHere = 26,
    CallForwarded = 27,
    CallForwardedToVoicemail = 28,
    SkypeTokenError = 29,
    CallAccepted = 30,
    LocalHttpStackError = 31, // Error provided by js http stack
    UnknownError = 32,
    PstnNoSubscriptionCover = 33,
    SessionNotFound = 34,
    SessionTimedOut = 35,
    PstnCreditExpired = 36,
    PstnCreditExpiredButEnough = 37,
    RetargetNotSupported = 38,
    EnterprisePstnInternalError = 39,
    EnterprisePstnUnavailable = 40,
    EnterprisePstnForbidden = 41,
    EnterprisePstnInvalidNumber = 42,
    EnterprisePstnMiscError = 43,
    Kicked = 44,
    NetworkRequestTimeoutError = 45, // When receiving a timeout on a network request
    CallDoesNotExist = 46,
    MediaSetupFailure = 47, // When failing to setup media due to timeout or answer errors
    ServiceUnavailable = 48,  // When the calling service is unavailable
    SignalingError = 49,  // When receiving errors from conversation service
    ConversationEstablishmentFailed = 50, // When establishing the conversation has failed
    TemporarilyUnavailable = 51,  // When the callee is temporarily unavailable
    CannotConnectToNetworkError = 52, // When connecting to the internet has failed
    MediaRelayWhiteListingIssue = 53,
    NoSignalingFromPeer = 54,
    DeniedInLobby = 55, // User in the lobby was denied
    TimedOutInLobby = 56, // If user in lobby was not admitted for extended time, and service ended the call with user due to timeout*/
    CallFailedConflict = 57, // outgoing call failure, there was incoming call from same person and it should be (auto) accepted
    DevicePermissionDenied = 58, // web - failed to obtain permission to use device ( mic/camera )
    ConfParticipantCountLimitReached = 59, // Max conf participants reached
    ActionNotAllowed = 60, // Tried to perform an action when it isn't allowed, for example some prerequisite state isn't met
    Abandoned = 61, // Result unknown because call ended
    ForbiddenDueToPolicy = 62,  // User doesn't have credentials to perform an activity
    InsufficientCapabilitiesForCallee = 63, // User isn't capable of cloud audio-video conferences
    UserBlocked = 64, // User is blocked by other participant
    AccessDenied = 65, // Default reason for PreconditionFailed
    AnonymousJoinDisabledByPolicy = 66, // Anonymous users cannot join by policy
    NoLobbyForBroadcastJoin = 67, // Lobby is not supported for broadcast meetings
    NotAllowedDueToInformationBarrier = 68, // Call failed due to an information barrier
    BroadcastLimitReached = 69, // Broadcast limit reached for the tenant
    TeamParkPolicyDisabled = 70, // Team park policy disabled for that user
    B2bJoinDisabledByPolicy = 71, // B2B users cannot join by policy
    LocationBasedRoutingError = 72, // Location based routing policy restriction error
    ConfLobbyParticipantCountLimitReached = 73 // Max number of lobby participants reached
}

export const enum DtmfTone {
    Num0 = 0,
    Num1 = 1,
    Num2 = 2,
    Num3 = 3,
    Num4 = 4,
    Num5 = 5,
    Num6 = 6,
    Num7 = 7,
    Num8 = 8,
    Num9 = 9,
    Star = 10,
    Pound = 11,
    A = 12,
    B = 13,
    C = 14,
    D = 15,
    Flash = 16
}

export const enum MediaPeerType {
    ConsumerTwoParty = 0,
    ConsumerPstn = 1,
    ConsumerMultiParty = 2,
    EnterpriseTwoPartyOnlineOnly = 3,
    EnterpriseTwoPartyHybrid = 4,
    EnterpriseMultiParty = 5,
    EnterprisePstnOnlineOnly = 6,
    EnterprisePstnHybrid = 7,
    EnterpriseFederated = 8,
    EnterpriseUnknown = 9,
    EnterpriseMultiPartyBroadcasting = 10
}

//represents MM_AUDIO_USAGE_MODE in msrtc
export const enum AudioUsageMode {
    Default = 'Default',
    LongrangeSpeaker = 'LongrangeSpeaker',
    Auditorium = 'Auditorium'
}

export interface MediaPortRanges {
    audioMin: number;
    audioMax: number;
    videoMin: number;
    videoMax: number;
    dataMin: number;
    dataMax: number;
    vbssMin?: number;
    vbssMax?: number;
}

export interface MediaConfiguration {
    openCameraInMaxResolution?: boolean;
    mediaPortRanges?: MediaPortRanges;
    enableMediaQoS?: boolean;
    enableAGC?: boolean;
    enableTtySupport?: boolean;
    setOutputSliderVolume?: number;
    enableSystemSoundSharing?: boolean;
    audioUsageMode?: AudioUsageMode;
    maxBandwidthInBps?: number;
}

// This is passed to 'join' calls and comes from ThreadUpdate chat messages
export interface SkypeConversationLiveState {
    conversationUrl: string;      // NOTE: This is actually for calling (bad words)
    conversationId: string;       // NOTE: This is actually a call ID (bad words)
    conversationType?: string;    // Indicates type ex: 'cast'
    groupCallInitiator?: string;
    expiration?: number;
    status?: string;
    isHostless?: boolean;
}

export const enum CallType {
    Unknown = -1,
    P2P = 1,
    Conference = 2
}

export const enum CallMeetingType {
    Unknown = -1,
    Private = 1,
    Channel = 2
}

export const enum VideoEffectType {
    Off                                 = 0,
    /* tslint:disable:no-bitwise */
    BackgroundBlurDefault               = 1 << 0,
    BackgroundBlurLight                 = 1 << 1,
    BackgroundBlurExperimental_1        = 1 << 2,
    BackgroundBlurExperimental_2        = 1 << 3,
    WhiteboardZoom                      = 1 << 4,
    WhiteboardCleanup                   = 1 << 5,
    WhiteboardZoomAndCleanup            = WhiteboardZoom | WhiteboardCleanup
    /* tslint:enable:no-bitwise */
}

export interface MeetingInfo {
    tenantId: string;
    organizerId: string;
    meetingType?: CallMeetingType;
    replyChainMessageId?: string;
}

export interface SessionTerminatedReason {
    terminatedReason: TerminatedReason;
    terminatedReasonCode: number;
    terminatedReasonSubCode: number;
    errorMessage?: string;
}

export interface CallAcknowledgeResult {
    code: CallAcknowledgeResultCode;
    success?: boolean;
    fatal?: boolean;
}

export const enum CallAcknowledgeResultCode {
    BadNotificationPayload,       // Fatal error: Indicates the input payload to acknowledge is improperly formatted.
    CallSetupSucceeded,           // Success: Indicates push handling succeeded and incoming call will ring.
    CallSetupFailed,              // Fatal error: Indicates push handling failed and incoming call will not ring.
    BadNotificationEventType,     // Fatal error: The event id is not a supported event. Supported values 105, 107, 109, 111.
    CallAlreadyExists,            // Non-fatal error: indicates client already is in the middle of joining the call.
    CallFailedCannotConnect,      // Fatal error: indicates client couldn't setup due to network issues.
    CallFailedNoSignaling,        // Fatal error: indicates client couldn't start call signaling.
    CallFailedConflict,           // Non-fatal error: indicates there is already an outgoing to same user.
    CallFailedPushIgnored,        // Non-fatal error: the push was ignored.
    CallFailedAnsweredElsewhere,  // Non-fatal error: the call was already answered elsewhere before this endpoint could process the push.
    CallFailedCallAlreadyEnded,   // Non-fatal error: call was either canceled by caller or timed out.
    CallSetupInProgress          // The call push was processed successfully and another callback will be raised when the push processing completes with result code.
}

export const enum ScreenScraperEvent {
    Ok,
    Started,
    Stopped,
    Error,
    WindowMinimized,
    WindowRestored,
    WindowFullyOccluded,
    WindowExposed,
    WindowClosed,
    PPTPresenterView_Enter,
    PPTPresenterView_Exit,
    WindowInPriviledgedProcess,
    OcclusionRemovalDisabled,
    FrameCount,
    Resolution
}

export interface BroadcastContext {
    // To be filled based on the definition used by service
}

export interface BroadcastState {
    // To be filled based on the definition used by the broadcast controller
    // This state object is send us by the Broadcast Modality controller as part of metadata change event.
    // It capture the state of composer service at that time, what sources it is subscribed to and results of recent commands executed.
}

export interface BroadcastLayout {
    // Will populate later when we have more concrete definition
}

/**
 * [Internal] Once we move to ts-calling, we should be ok to get rid of this.
 * This is currently just used in BroadcastMeeting class.
 */
export interface BroadcastMetadata {
    broadcastControllerUrl?: string;
    broadcastStateCallbackUrl?: string;
    broadcastState?: BroadcastState;
}

export const enum BroadcastModalityState {
    None = 0,
    Ringing = 1,
    Connecting = 2,
    Connected = 3,
    Disconnected = 4
}

export interface IBroadcastMeeting extends IObservableObject<{}> {
    modalityState: BroadcastModalityState;
    broadcastState: BroadcastState;

    /**
     * Expose role of the event team member
     */
    role: string;

    setLayout(layout: BroadcastLayout): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    joinModality(): Promise<void>;

    // These are the internal methods/variables and will be removed once we move from teams repo
    // Discussed with swapna, we refer class (instead of interface) in the concrete implementation of call object
    // These properties/method can be added in class and removed from interface
    context: BroadcastContext;
    // Will be called by call object to notify metadata has changed
    metadataChanged(rawMetadata: string): void;
}

export interface ProxiedPushNotificationEvent {
    eventId: number;
    payload: string;
}

export interface LogUploadNotificationEvent {
    eventId: number;
    payload: string;
}

export interface ICallRegistryEvents {
    skypeTokenRequired(invalidToken: string): void;
    callAdded(call: ICall): void;
    callRemoved(call: ICall): void;
    proxiedPushNotification(event: ProxiedPushNotificationEvent): void;
    logUploadNotification(event: LogUploadNotificationEvent): void;
    disposed(): void;
}

// CallRegistry is user specific and should be create once per user.
// if dispose is called, it is considered to be deleted.
// after that and will throw on login.
export interface ICallRegistry extends IObservableObject<ICallRegistryEvents> {
    calls: ICall[];

    readonly identity: string;

    // set ring/tenantId of the user.
    // used only for telemetry.
    setRing(ring: string): Promise<void>;
    setTenantId(tenantId: string): Promise<void>;

    // update the displayname associated with the user.
    // the displayname is used for the calls created post the update.
    // this will not update the displayname on the existing calls.
    updateDisplayName(displayName: string): Promise<void>;

    // update skypetoken associated with the user.
    updateSkypeToken(skypeToken: string): void;

    // to fire intent specific to a user.
    fireIntent(intent: CallingIntent, identity?: string): Promise<void>;

    // user specific ecs provider and configuration setup.
    getEcsProvider(): IEcsProvider;
    getSetup(): ISetup;

    // dispose the ICallRegistry instance.
    // It logs out the user and the registry is considered to be disposed/deleted.
    dispose(causeId?: CauseId): Promise<void>;

    // localParticipantId allows using a specific GUID for outbound calls,
    // otherwise a random one will be assigned.
    // Return existing call if:
    //      ThreadId and callId of existing call matches with input.
    //      ThreadId and messageId of existing call matches with input.
    //      callId and localParticipantId of existing call matches with input.
    createCall(threadId: string, callId?: string, localParticipantId?: string, messageId?: string, causeId?: CauseId): ICall;

    // Retrieves the call if:
    //      Call.State is observing and callId matches with input.
    //      Call.State is not observing but callId and localParticipantId matches with input.
    getCall(callId: string, localParticipantId: string, causeId?: CauseId): ICall;

    deleteCall(call: ICall, final?: boolean, causeId?: CauseId): boolean;

    // Gets debug information for the specified call (if provided), or the most recent available call.
    debugInformation(call?: ICall): Promise<string>;

    //DEPRECATED - use getCallRegistry(identity: SkypeIdentity) instead.
    init(skypeIdentity: SkypeIdentity, initOptions?: CallingStackInitOptions, causeId?: CauseId): Promise<void>;
    uninit(): Promise<void>;
    login(skypeIdentity: SkypeIdentity, causeId?: CauseId): Promise<void>;
    logout(causeId?: CauseId): Promise<void>;
}

export interface CallInitOptions {
    mediaPeerType: MediaPeerType;
    threadId: string;
    messageId?: string;
    enableGroupCallMeetupGeneration?: boolean;
    meetingInfo?: MeetingInfo;
    transferContext?: ICallTransferContext<any>;
    broadcastContext?: BroadcastContext;
    endpointMetadata?: string;
    onBehalfOf?: string;
    emergencyContent?: string;
}

export type RoutingFlags = 'preferSfB';

//----------------------------------------------------------------------------
// Modality                  MediaDirection
//----------------------------------------------------------------------------
// audioDirection       Bidirectional - default
//
//                      Inactive - if audio is not needed
//
//                      Disabled, SendOnly, ReceiveOnly - NotAllowed
//----------------------------------------------------------------------------
// videodirection       Bidirectional - VideoCall
//
//                      ReceiveOnly - default
//
//                      Disabled - if video is not needed
//
//                      SendOnly, Inactive - NotAllowed
//----------------------------------------------------------------------------
// screenshareDirection SendOnly - if screenshare is to be initiated
//
//                      ReceiveOnly - default for groupCalls
//                      Disabled - default for 1-1 calls
//
//                      Bidirectional, Inactive - NotAllowed
//----------------------------------------------------------------------------
// datachannelDirection Bidirectional - if datachannel is needed
//
//                      Disabled - default
//
//                      SendOnly, ReceiveOnly, Inactive - NotAllowed
//----------------------------------------------------------------------------
export interface CallStartOptions {
    ringOthers?: boolean;
    withVideo?: boolean; // to be deprecated
    audioDirection?: MediaDirection;
    videoDirection?: MediaDirection;
    screenshareDirection?: MediaDirection;
    datachannelDirection?: MediaDirection;
    maxVideoChannels?: number;
    // Affects pluginless stack only
    muted?: boolean; // Used to determine if media state is receive only
    muteFlags?: MuteFlags;
    label?: string;
    isCast?: boolean;
    callKey?: string;
    encryptedKey?: string;
    connectionType?: ConnectionType;
    negotiationTag?: string;
    routingFlags?: RoutingFlags[];
    isLwj?: boolean; // Deprecated - use PluginlessStackConfig.allSettings.useLwjForAllCalls instead
    preheatFlags?: PreheatFlags;

    // For telemetry captured by client and server.
    // Recommended passing strings like "twopartycall", "groupcall", "channelmeetup", "scheduledmeetup",
    //  "adhocmeetup", "privatecall", "unpark", "testcall", "testmeeting" etc.
    scenario?: string;
}

export interface CallAcceptOptions {
    withVideo?: boolean; // to be deprecated
    answerMediaType?: AnswerMediaType;
    // Affects pluginless stack only
    muted?: boolean;
}

export interface JoinPreheatedCallOptions {
    muteFlags?: MuteFlags;
}

export type VoicemailResourcePath = 'voicememo' | 'greeting' | 'voicemail' | '';

export type MeetingRole = 'attendee' | 'presenter' | 'organizer' | '';

export type PresenterOption = 'Everyone' | 'EveryoneInCompany' | 'Specified' | 'OnlyMe' | '';

export interface CallVoicemailStartOptions {
    // Voicemail resource for different voicemail scenarios.
    // For call to other's voicemail, use "voicememo".
    // For setting or listening to self greeting, use "greeting".
    // For listening to self voicemail message, use empty string.
    // For playing a specific self voicemail message, use "voicemail"
    voicemailResourcePath?: VoicemailResourcePath;
    // Specify a particular voicemail item for the voicemail service to play.  This is
    // only applicable to the play a specific self voicemail message scenario
    voicemailItemId?: string;
}

// participantInvitationData: JSON formatted blob
export interface AddParticipantPayload {
    threadId?: string;
    messageId?: string;
    sipUri?: string;
    participantInvitationData?: any;
}

export type ScraperEventArgs = {
    event: ScreenScraperEvent;
    data: number;
};

export type IncomingCallType = 'default' | 'transfer' | 'forward' | 'replaces';
export type ForwardingDestinationType = 'none' | 'user' | 'delegates' | 'group' | 'voicemail' | 'team';
export type TransferorType = 'unknown' | 'delegator' | 'groupMember';
export type CallProgressStatus = 'queued';
export interface ICallEvents {
    callIdChanged(correlationId: string): void;
    callLegIdChanged(participantId: string): void;
    callQualityChanged(event: QualityChangedEvent): void;
    callStateChanged(): void;
    mediaConnectionFailed(): void;
    mediaConnectionWhitelistingWarning(): void;
    mediaStreamStateChanged(info?: MediaStreamInfo): void;
    sharingDropped(): void;
    lwjFallbackStarted(): void; // The call has experienced a media-related issue and is attempting to reconnect in LWJ mode
    serverMutedChanged(isServerMuted: boolean): void;
    sharingStolen(): void;
    statsReported(): void;
    transferRequested(info: CallTransferInfo<any>): void;
    userActivityChanged(): void;
    contentSharingChanged(): void;
    lwjChanged(info: LwjSessionInformation): void; // Local endpoint's LWJ session information changed (from roster)
    broadcastMetadataChanged(): void;
    replacementRequested(message: any): void;
    participantAdded(participant: ICallParticipant): void;
    participantRemoved(participant: ICallParticipant): void;
    participantUpdated(participant: ICallParticipant): void;
    callProgressStatusChanged(status: CallProgressStatus): void;
    sharingRenderedAtViewer(participantId: string): void;
    scraperEvent(args: ScraperEventArgs): void;
    meetingRoleUpdated(role: MeetingRole): void;
}

export interface ICall extends IObservableObject<ICallEvents> {
    // The globally unique guid representing the call.
    callId: string;

    // The thread associated with the call.
    threadId: string;
    callType: CallType;
    callerMri: string;

    // Endpoint id unique endpoint for the device and does not change across calls.
    endpointId: string;

    // This is a session id for the call. The id can change for the same call if user joins the same call again.
    participantId: string;

    // The local call states.
    state: CallState;
    transferState: TransferState;
    origin?: CallOrigin;
    parkState: ParkState;
    invitationData?: any; // Invitation data from incoming addParticipant/nudge
    participants: ICallParticipant[];
    dominantSpeakerInfo: DominantSpeakerInfo;
    callStartedAt: Date;
    callHeldAt?: Date;
    isAudioStreamConnected?: boolean;

    // Active media streams from the user's other endpoints.
    mediaStreams: CallParticipantStreamMap;

    // This represents the local mute state.
    isMuted: boolean;

    // Indicates if the local endpoint is also muted on the service in a group call. This property is applicable only for group calls.
    // This is the aggregated mute state for the user across all endpoints.
    // i.e isServerMuted is true only if participant is muted on all endpoints and false otherwise.
    isServerMuted: boolean;

    // This represents the local mute state for speaker or other audio output
    isSpeakerMuted: boolean;

    // TODO: should be removed and represented on local call object.
    // Used to identify the conversation for Teams client because threadId will be null for a 1:1 call.
    conversationId?: string;

    // T0D0: should be removed and states must be represented on local video and screen share object itself.
    isVideoOn: boolean;
    isScreenSharingOn: boolean;
    terminatedReason: TerminatedReason;
    failureType: FailureType;
    callEndDiagnosticsInfo?: CallEndDiagnosticsInfo;
    messageId?: string;
    isCast?: boolean;
    label?: string;
    isHostless?: boolean;
    endpoints?: CallParticipantEndpoints;
    meetingDetails?: MeetingDetails;
    role?: ParticipantRosterRole;
    meetingRole?: MeetingRole; // MeetingRole for myself
    tenantId?: string;
    transferorMri?: string;
    transferorDisplayName?: string;
    transferorType?: TransferorType;
    onBehalfOfMri?: string;
    callQueueInfo?: CallQueueInfo;
    incomingCallType?: IncomingCallType;
    consultativeCallId?: string;
    isIncomingOneOnOneVideoCall?: boolean;
    forwardingDestinationType?: ForwardingDestinationType;
    optimalVideoCount?: number;
    contentSharingSessions: IContentSharingSession[];
    screenSharingControl?: IScreenSharingControl;
    broadcastMeeting?: IBroadcastMeeting;
    broadcastMetadata?: BroadcastMetadata;
    dataChannelAdapter?: IDataChannelAdapter;

    init(callInitOptions: CallInitOptions): void;
    join(context: SkypeConversationLiveState, callStartOptions: CallStartOptions, causeId?: CauseId): Promise<void>;
    joinCallWithoutCallModality(context: SkypeConversationLiveState, callStartOptions?: CallStartOptions, causeId?: CauseId): Promise<void>;
    // Used to join a call that is already preheated/being preheated using the preheat flags in start/join
    joinPreheatedCall(joinPreheatedCallOptions?: JoinPreheatedCallOptions, causeId?: CauseId): Promise<void>;
    start(callStartOptions: CallStartOptions, causeId?: CauseId): Promise<void>;
    startCallToVoicemail(callStartOptions: CallVoicemailStartOptions, causeId?: CauseId): Promise<void>;
    // Nudge is used by consumer clients to show a different notification to the invitees and not ring them
    startCallWithNudge(participants: string[], callStartOptions: CallStartOptions, causeId?: CauseId): Promise<void>;
    // start call and unpark it
    startAndUnpark(parkContext: ParkContext, pickupCode: PickUpCode, callStartOptions: CallStartOptions, causeId?: CauseId): Promise<void>;
    park(parkContext: ParkContext, causeId?: CauseId): Promise<PickUpCode>;
    updateMeetingRoles(participants: string[], meetingRole: MeetingRole, causeId?: CauseId): Promise<void>;

    acknowledge(incomingCall: IncomingCallPayload, endpointMetadata?: string, causeId?: CauseId): Promise<CallAcknowledgeResult>;
    accept(callAcceptOptions: CallAcceptOptions, causeId?: CauseId): Promise<void>;
    reject(causeId?: CauseId): Promise<void>;
    admitParticipant(participantId: string, causeId?: CauseId): Promise<void>;
    addParticipant(participantId: string, payload?: AddParticipantPayload, causeId?: CauseId): Promise<ICallParticipant>;
    // Nudge is used by consumer clients to show a different notification to the invitees and not ring them
    nudgeParticipants(context: string, participants: string[], payload?: AddParticipantPayload, causeId?: CauseId): Promise<void>;
    // Initiates a call me back scenario.
    // The parameter participantMri is the to user mri.
    // The parameter assertedId is the mri of the callMeBack operation initiator.
    // AssertedMri is made an optional parameter to support future extensibility of the API.
    // If assertedMri is not specified, it would be default to the callMebBack operation initiator's mri.
    callMeBack(participantMri: string, assertedMri?: string, causeId?: CauseId): Promise<void>;
    removeParticipant(participantId: string, causeId?: CauseId, endpoint?: string, endpointScope?: RemoveEndpointScope): Promise<void>;
    stop(forEveryone?: boolean, causeId?: CauseId): Promise<void>;

    // Mutes and unmutes the local endpoint's microphone
    mute(causeId?: CauseId): Promise<void>;
    unmute(causeId?: CauseId): Promise<void>;

    // Mutes the remote participants' microsphone.
    // When MuteScope=All and input participant list is empty, everyone excluding self are muted.
    // When MuteScope=All and input participant list is not empty, everyone excluding the input participants and self are muted.
    // When MuteScope=Specified, the specified input list of participants alone are muted.
    muteParticipants(muteScope: MuteScope, callParticipants: ICallParticipant[], causeId?: CauseId): Promise<void>;

    // Mutes and unmutes the local speaker/audio output
    muteSpeaker(causeId?: CauseId): Promise<void>;
    unmuteSpeaker(causeId?: CauseId): Promise<void>;

    hold(negotiationTag?: string, causeId?: CauseId): Promise<void>;
    unhold(negotiationTag?: string, causeId?: CauseId): Promise<void>;

    updateEndpointMetadata(endpointMetadata: string, causeId?: CauseId): Promise<void>;
    sendDtmfTone(dtmfTone: DtmfTone, causeId?: CauseId): Promise<void>;

    // Pass 5 for max video channels especially when negotiating datachannel as part of join
    setMaxVideoChannels(maxVideoChannels: number): Promise<void>;
    setVideoContainer(node: IRenderTarget, options?: StartStreamOptions, causeId?: CauseId): Promise<void>;
    // local video
    startVideo(negotiationTag?: string, causeId?: CauseId): Promise<void>;
    stopVideo(negotiationTag?: string, causeId?: CauseId): Promise<void>;
    // local audio
    startAudio(negotiationTag?: string, causeId?: CauseId): Promise<MediaNegotiationStatusCode>;
    stopAudio(negotiationTag?: string, causeId?: CauseId): Promise<MediaNegotiationStatusCode>;
    // screen sharing
    startScreenSharing(source?: ISharingSource, cropRegion?: Rectangle, negotiationTag?: string, causeId?: CauseId): Promise<void>;
    changeCropRegion?(cropRegion: Rectangle): void;
    stopScreenSharing(isSharerSwitch?: boolean, negotiationTag?: string, causeId?: CauseId): Promise<void>;
    // data channel
    startDataChannel?(negotiationTag?: string, causeId?: CauseId): Promise<void>;
    stopDataChannel?(negotiationTag?: string, causeId?: CauseId): Promise<void>; // Only use stopDataChannel when specifically necessary - it's preferred to let it stay active rather than restarting later

    shareSystemSound(enable: boolean): Promise<void>;
    disposeLocalVideoRenderer(causeId?: string): Promise<void>;
    transferCall(transferTargetMri: string, causeId?: CauseId): Promise<TerminatedReason>; // Deprecated - use callBlindTransfer instead
    callBlindTransfer(transferTargetMri: string, causeId?: CauseId): Promise<TerminatedReason>;
    callSafeTransfer(transferTargetMri: string, causeId?: CauseId): Promise<TerminatedReason>;
    callConsultativeTransfer(callWithTarget: ICall, causeId?: CauseId): Promise<TerminatedReason>;

    // Assimilates the input call into the current call. callToAssimilate must be a two party call only.
    assimilate(callToAssimilate: ICall, threadId?: string, messageId?: string, causeId?: CauseId): Promise<TransactionEnd>;

    // Get the cc url for server held call chained to resolved
    // after park completion promise
    getServerHoldLocation(): Promise<string>;

    // Technical information is JSON formatted string used for debugging purpose only.
    // This API also blocks and can cause perf issues if called too often so recommend calling
    // it no less than 10 second frequency.
    getTechnicalInformationJson(): Promise<string>;

    createContentSharingSession(contentSharingGuid: string, contentSharingIdentity: string, subject?: string, initialContentSharingSessionState?: string, causeId?: CauseId): Promise<IContentSharingSession>;

    //The method allows to configure audio usage mode for current call.
    setAudioUsageMode(audioUsageMode: AudioUsageMode, causeId?: string): Promise<void>;

    // Initiates reconnect
    // Used for testing purposes
    reconnect(): Promise<void>;

    // CQF
    provideCallQualityFeedback(questionaryId: string, trackingReason: string, rating: number, problemTokens: string): Promise<void>;

    // Video Effects
    setVideoEffects(effectsType: VideoEffectType): Promise<void>;
    // resolve promise to a bit mask of EffectsType
    getVideoEffectsCapability(): Promise<number>;

    dumpVideoSourceImages(): Promise<number>;
}

export interface SkypeIdentity {
    id: string;
    displayName: string;
    tokenProvider(): Promise<string>;
    sipUri?: string;
}

export type CallQueueInfo = {
    type: string;
    details: {
        id: string;
        displayName: string;
    };
    onBehalfOf: {
        id: string;
        displayName: string;
    };
};

export const enum DeviceType {
    Camera = 1,
    Microphone = 2,
    Speaker = 3,
    CompositeAudioDevice = 4
}

export const enum CameraPosition {
    Unknown = 0,
    Front = 1,
    Back = 2,
    External = 3,
    LeftFront = 4,
    RightFront = 5
}

export const enum SharingSourceType {
    Monitor = 1,
    Window = 2,
    Camera = 3
}

export type DeviceId = string;

export interface DeviceDesc {
    id: DeviceId;
    browserId?: DeviceId;
    label: string;
    kind: DeviceType;
}

export interface AudioDeviceDesc extends DeviceDesc {
    isSystemDefault: boolean;
    productId?: string;
    vendorId?: string;
}

export interface VideoDeviceDesc extends DeviceDesc {
    position: CameraPosition;
}

export const enum CompositeAudioDeviceFormFactor {
    Unknown = 0,
    Speakers = 1,
    Headphones = 2,
    Headset = 3,
    Handset = 4,
    Speakerphone = 5
}

export interface CompositeAudioDeviceDesc extends DeviceDesc {
    microphoneId: DeviceId;
    speakerId: DeviceId;
    formFactor: CompositeAudioDeviceFormFactor;
    isPcInternalDevice: boolean;
}

export type SelectedDevices = {
    microphone?: DeviceId;
    speaker?: DeviceId;
    camera?: DeviceId;
};

export type DeviceAccess = {
    audio: boolean;
    video: boolean;
};

export interface IDeviceManagerEvents {
    devicesChanged(devices: DeviceDesc[]): void;
}

export interface IDeviceManager extends IObservableObject<IDeviceManagerEvents> {
    readonly isAudioOutputSelectionSupported: boolean;
    askDevicePermission(constraints?: DeviceAccess): Promise<DeviceAccess>;
    enumerateDevicesAsync(): Promise<DeviceDesc[]>;
    selectDevices(devices: SelectedDevices): void;
    enableTtySupport(enable: boolean): Promise<void>; // deprecated, use ICallingStack.setMediaConfig
    getSelectedDevices(): SelectedDevices;
    createPreviewRenderer(target: IRenderTarget, options?: StartStreamOptions, causeId?: CauseId): Promise<IRenderer>;
    createScreenSharingPreviewRenderer(target: IRenderTarget, options?: StartStreamOptions, causeId?: CauseId): Promise<IRenderer>;
    getDeviceNameAsync(deviceId: DeviceId): Promise<string>;
    setDeviceEffects?(deviceId: DeviceId, type: VideoEffectType): void;  // deprecated
    setDeviceEffectsAsync(deviceId: DeviceId, type: VideoEffectType): Promise<void>;
    getDeviceEffectsCapability?(deviceId: DeviceId, mask?: number): number; // deprecated
    getDeviceEffectsCapabilityAsync(deviceId: DeviceId, mask?: number): Promise<number>;
    getSpeakerVolume(): Promise<number>;
    getSpeakerSystemVolume(): Promise<number>;
    setSpeakerVolume(volume: number): Promise<void>;
    setSpeakerSystemVolume(volume: number): Promise<void>;
    unmuteMicrophone(): Promise<void>;
    unmuteSpeaker(): Promise<void>;
    getNrgLevelsForDeviceTuner(microphone: string): Promise<number>;
    getMicrophoneVolume(): Promise<number>;
    setMicrophoneVolume(volume: number): Promise<void>;
}

export interface Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}

export interface ImageInfo {
    width: number;
    height: number;
    uri: string;
}

export interface ISharingSource {
    // To be migrated to string id api getDeviceId
    getId(): number;
    getDeviceId?(): string;
    getType(): SharingSourceType;
    getPreview?(width?: number, height?: number, asImage?: boolean): Promise<ImageInfo>;
    getPreviewAsync(width?: number, height?: number, asImage?: boolean): Promise<ImageData>;
    getDescription(): string;
    getAppName?(): string;
    getIcon(width?: number, height?: number, asImage?: boolean): Promise<ImageData>;
    getBounds(): Rectangle;
}

export interface IScreenSharingManagerEvents {
    screensChanged(): void;
}

export interface IScreenSharingManager extends IObservableObject<IScreenSharingManagerEvents> {
    enumerateScreensAsync(): Promise<ISharingSource[]>;
    enumerateWindowsAsync(): Promise<ISharingSource[]>;
    enumerateCamerasAsync(): Promise<ISharingSource[]>;
}

export interface ISetup {
    setString(key: string, value: string): Promise<void>;
    setNumber(key: string, value: number): Promise<void>;
    getString(key: string): Promise<string>;
    getNumber(key: string): Promise<number>;
    delete(key: string): Promise<void>;
}

// ecsBlob: JSON formatted blob from ECS
// etag: ECS etag
export interface EcsConfig {
    ecsBlob: string;
    userIdentity: string;
    etag: string;
}

export interface IEcsProvider {
    setEcsConfig(config: EcsConfig): Promise<void>;
    getEcsQueryParameters(): Promise<string>;
}

export interface ICallingStackEvents {
    // (See getE911Info() comment.)
    e911InfoChanged(info: string): void;
    mediaStatusChanged(mediaStatus: MediaStatus): void;
}

export interface ICallingStackError extends Error {
    readonly callSupport: CallSupport;
}

export const enum TelemetryDiagnosticLevel {
    Zero = 'Zero',
    Basic = 'Basic',
    Full = 'Full'
}

// A struct with options for how to initialize callingStack.
// Currently only supports block, but can be expanded upon
// in the future
export interface CallingStackInitOptions {
    block?: boolean;
    lazyMediaInit?: boolean;
    telemetryDiagnosticLevel?: TelemetryDiagnosticLevel;
}

// CallingStack is app specific and should be create once per app's lifetime.
// init should be called only once for the entire process.
// if dispose is called, it is considered to be deleted after that and will throw on init.
export interface ICallingStack extends IDisposable, IObservableObject<ICallingStackEvents> {
    init(initOptions?: CallingStackInitOptions, causeId?: CauseId): Promise<void>;

    getCallRegistry(): ICallRegistry; // DEPRECATED - use the method below.
    // CallRegistry is created once per unique identity.
    getCallRegistry(identity: SkypeIdentity, causeId?: CauseId): Promise<ICallRegistry>;
    readonly callRegistries: ICallRegistry[];

    getDeviceManager(): IDeviceManager;
    getScreenSharingManager(): IScreenSharingManager;
    getSetup(): ISetup; // Global setup not specific to user.
    getEcsProvider(): IEcsProvider; // Global ecs not specific to user.
    getVersion(): TsCallingVersion;
    getMediaStatus(): MediaStatus;
    setMediaConfig(configuration: MediaConfiguration) : Promise<void>;

    fireIntent(intent: CallingIntent, identity?: string): void; // DEPRECATED - use fireIntent from ICallRegistry

    //  getE911Info() and the e911InfoChanged event both return compact
    //  (no indents/linefeeds) JSON strings with the following format:
    //
    //    {
    //       "bssid": "<string>",
    //       "e911": [
    //           {
    //               "chassisId": "<string>",
    //               "portId": "<string>"
    //           },
    //           ...
    //       ]
    //       "ipv4": "<IP Address in string format>",
    //       "ipv6": "<IP Address in string format>",
    //       "mac": "<string>",
    //       "subnetLengthIPv4": "<string>",
    //       "subnetLengthIPv6": "<string>"
    //    }
    //
    getE911Info?(): Promise<string>;
}

export type TsCallingVersion = {
    build: string;
    ovb: string;
};

export type CallingLoggerPrefixFunction = () => string;

export interface CallingLogger {
    createChild(namespace: string | CallingLoggerPrefixFunction, debug?: boolean): CallingLogger;
    log(...values: any[]): void;
    debug(...values: any[]): void;
    info(...values: any[]): void;
    warn(...values: any[]): void;
    error(...values: any[]): void;
}

export interface ICallTransferContext<T> {
    transferorMri: string;
    targetMri: string;
    context: T;
    transferType?: TransferType;
}

export interface CallTransferInfo<T> {
    transferContext: ICallTransferContext<T>;
    onCompleted(code: TerminatedReason): void;
}

export interface IMediaDataChannelEvents {
    stateChange(state: MediaDataChannelState): () => void;
}

export interface IMediaDataChannel {
    start(negotiationTag?: string): Promise<void>;
    stop(negotiationTag?: string): Promise<void>;
}

// a wrapper around the real send function so that the implementation can be replaced by different transports in the future
export type DataSendFunction = (data: Uint8Array, recipients?: number[]) => Promise<void>;

// data channel handler to expose various states on the data channel, giving clients the autonomy to manage
// the actions when data channel is started or stopped or when communication is received on it.
export interface IDataChannelHandler {
    onStarted(dataId: number, send: DataSendFunction): Promise<void>;
    onStopped(dataId: number): Promise<void>;
    onDataReceived(dataId: number, data: Uint8Array, sourceId: number): Promise<void>;
}

// exposing an API that allows business logic to register/de-register data channel handlers directly
export interface IDataChannelAdapter {
    // Register a new handler for the specified data channel id.
    // Also ensures the data channel is started as soon as we have at least one handler and data channel is in the available state.
    addHandler(dataId: number, adapter: IDataChannelHandler, skipDataSourceSinkCreation?: boolean, negotiationTag?: string): Promise<void>;

    // De-Register a  handler for the specified data channel id.
    removeHandler(dataId: number): Promise<void>;

    updateNegotiationTag(negotiationTag?: string): Promise<void>;
}

export interface IScreenSharingControlEvents {
    sharingRendererClicked(): void;
    sharingRendererMouseEntering(): void;
    sharingRendererMouseLeaving(): void;
    sharingControlCapable(capability: SharingControlCapability): void;
    sharingIncomingControlRequest(id: string): void;
    sharingIncomingControlRequestCancelled(id: string): void;
    sharingControlChanged(controlInfo: SharingControlInfo): void;
    sharingControlError(error: SharingControlError): void;
    controlAvailableHandshake(handshakeId: string, sourceId: number, status: AvailableHandshakeStatus, reason?: AvailableHandshakeTerminatedReason): void;
    controlDataChannelStateChanged(channelStatus: { id: number; state: MediaDataChannelState; readyForControl: boolean }): void;
}

export interface IScreenSharingControl extends IObservableObject<IScreenSharingControlEvents> {

    controlState: ControlState;
    role: SharingControlRole;
    enableScreenSharingControl(enabled: boolean, reason?: SharingControlDisableReason, detail?: any, allowControlForUser?: Function): void;
    setScreenSharingControlFeatureFlag(enabled: boolean): void;
    isScreenSharingControlEnabled(): boolean;
    setRenderer(renderer: IRenderer, target?: IRenderTarget): Promise<void>;
    setPointerImage(participant: ICallParticipant, base64img: string): Promise<void>; // deprecated
    setLocalPointerImage(base64img: string): Promise<void>;
    setRemotePointerImage(participant: ICallParticipant, base64img: string): Promise<void>;
    startPointerMode(): Promise<void>;
    stopPointerMode(): Promise<void>;
    requestControl(): Promise<void>;
    acceptControlRequest(): Promise<void>;
    denyControlRequest(): Promise<void>;
    grantControl(participant: ICallParticipant): Promise<void>;
    terminateControl(): Promise<void>;
}

/**
 * Describes available operations on a Content Sharing session.
 *
 * Content Sharing contoller is a generic controller that allows clients to send
 * content between themselves. The controller and interfaces are somewhat general, but the
 * first usecase will be Document Sharing via WAC service
 */
export interface IContentSharingSession extends IObservableObject<{}> {
    // The metadata for the session
    contentSharingState: string;

    // The status for the session (connecting, presenting etc.)
    contentSharingStatus: ContentSharingStatus;

    // Content sharing termination reason. Provides additional debug content when session disconnects
    contentSharingTerminationReason: SessionTerminatedReason;

    // The identity for the session. For instance could be the WAC URL for a doc sharing session
    contentSharingIdentity: string;

    // Unique identifier for the session
    contentSharingGuid: string;

    /**
     * Starts a content sharing session.
     * Each implementation should cache all the start required parameters in their constructor
     */
    startContentSharing(causeId?: CauseId): Promise<void>;

    /**
     * Join an incomming content sharing session
     */
    joinContentSharing(causeId?: CauseId): Promise<void>;

    /**
     * Update ContentSharing session state
     */
    updateContentSharingSessionState(id: string, sessionState: string, causeId?: CauseId): Promise<void>;

    /**
     * Take control of the Content Sharing session
     */
    takeContentSharingControl(causeId?: CauseId): Promise<void>;

    /**
     * Update self-participant ContentSharing state to Viewer
     */
    updateContentSharingParticipantStateToViewer(causeId?: CauseId): Promise<void>;

    /**
     * Stop ContentSharing session
     */
    stopContentSharing(causeId?: CauseId): Promise<void>;
}

// Protocol messages deliver to corresponding enum dataChannelUser
export const enum DataChannelProtocolType {
    ScreenSharingControl = 0,
    Adapter
}

export type DataChannelProtocolMessage = {
    type: DataChannelProtocolType;
    message: string;
};

export const enum ParticipantContentSharingRole {
    None = 0,
    Attendee = 1,
    Presenter = 2
}
export const enum ContentSharingStatus {
    None = 0,
    Connecting = 1,
    Ringing = 2,
    Presenting = 3,
    Connected = 4,
    Viewing = 5,
    Finishing = 6,
    Done = 7,
    Failed = 8
}

export const enum MediaDataChannelState {
    Unknown,
    Available,
    Starting,
    Active,
    Stopping,
    NotStarted
}

export const enum SharingControlRole {
    Unknown,
    Sharer,
    Viewer
}

export interface SharingControlInfo {
    inControl: boolean;
    id: string;
    terminatedReason?: ControlTerminatedReason;
}

export interface SharingControlCapability {
    capable: boolean;
    id: string;
    disabledBySharer?: boolean;
}

export const enum AvailableHandshakeStatus {
    Unknown,
    Sending,
    Resending,
    Acking,
    Dropping,
    Succeeded,
    Terminated,
    Rejecting
}

export const enum AvailableHandshakeTerminatedReason {
    Unknown,
    Succeeded,
    Shutdown,
    DataChannel,
    Replaced,
    TimedOut,
    UnknownSender,
    SharerDenied
}

export const enum SharingControlErrorReason {
    SetInjectorConfigError,
    InjectRawInputError,
    SetInjectionRectError,
    AllowSingleControllerError,
    AvailableAckTimeout,
    SendDataError,
    DataChannelInactive
}

export const enum SharingControlDisableReason {
    SetInjectionFailed,
    DisabledDWM
}

// JSON format details
export interface SharingControlError {
    reason: SharingControlErrorReason;
    detail?: string;
}

export const enum MediaStatus {
    NotAvailable,
    Initialized,
    Failed,
    Uninitialized
}

} // declare module skype.calling

declare module 'skype-calling-interface' {
    import ExportedNamespace = skype.calling;
    export = ExportedNamespace;
} // declare module 'skype-calling-interface'

declare module '@skype/skype-calling-interface' {
    import ExportedNamespace = skype.calling;
    export = ExportedNamespace;
} // declare module '@skype/skype-calling-interface'
